2)设计测试用例，以便覆盖所有的有效等价类在表中列出了3个有效等价类，编号分别为①、⑤、⑧，
设计的测试用例如下： 测试数据 期望结果 覆盖的有效等价类 200211 输入有效 ①、⑤、⑧ 
3)为每一个无效等价类设计一个测试用例，设计结果如下： 测试数据 期望结果 覆盖的无效等价类 95June 无效输入 
② 20036 无效输入 ③ 2001006 无效输入 ④ 198912 无效输入 ⑥ 200401 无效输入 
⑦ 200100 无效输入 ⑨ 200113 无效输入 ⑩ 3.NextDate 函数包含三个变量：month 、 day 和 year ，
函数的输出为输入日期后一天的日期。 例如，输入为 2006年3月 7日，则函数的输出为 2006年3月8日 。
要求输入变量 month 、 day 和 year 均为整数值，并且满足下列条件： ①1≤month≤12 ②1≤day≤31 
③1920≤year≤2050 1)有效等价类为： M1＝{月份：1≤月份≤12} D1＝{日期：1≤日期≤31} Y1＝{年：1812≤年≤2012} 
2)若条件 ① ~ ③中任何一个条件失效，则 NextDate 函数都会产生一个输出，指明相应的变量超出取值范围，
比如 "month 的值不在 1-12 范围当中 " 。显然还存在着大量的 year 、 month 、 day 的无效组合，
NextDate 函数将这些组合作统一的输出： " 无效输入日期 " 。
其无效等价类为： M2＝{月份：月份<1} M3＝{月份：月份="">12} D2＝{日期：日期<1} D3＝{日期：日期="">31} Y2＝{年：年<1812} Y3＝{年：年="">2012} 
弱一般等价类测试用例 月份 日期 年 预期输出 6 15 1912 1912年6月16日 强一般等价类测试用例同弱一般等价类测试用例 
注：弱--有单缺陷假设；健壮--考虑了无效值 (一)弱健壮等价类测试 用例ID 月份 日期 年 预期输出 WR1 6 15 1912 1912年6月16日 WR2 -1 15 1912 月份不在1～12中 WR3 13 15 1912 月份不在1～12中 WR4 6 -1 1912 日期不在1～31中 WR5 6 32 1912 日期不在1～31中 WR6 6 15 1811 年份不在1812～2012中 WR7 6 15 2013 年份不在1812～2012中</1812}></1}></1}>

(二)强健壮等价类测试 用例ID 月份 日期 年 预期输出 SR1 -1 15 1912 月份不在1～12中 SR2 6 -1 1912 日期不在1～31中 SR3 6 15 1811 年份不在1812～2012中 SR4 -1 -1 1912 两个无效一个有效 SR5 6 -1 1811 两个无效一个有效 SR6 -1 15 1811 两个无效一个有效 SR7 -1 -1 1811 三个无效 
4.佣金问题等价类测试用例，它是根据佣金函数的输出值域定义等价类，来改进测试用例集合。
输出销售额≤1000元 佣金10％1000<销售额≤1800 佣金=100+(销售额-1000)15%销售额>1800 佣金=220+(销售额-1800)20%测试用例 枪机(45) 枪托(30) 枪管(25) 销售额 佣金 1 5 5 5 500 50 2 15 15 15 1500 175 3 25 25 25 2500 360根据输出域选择输入值，使落在输出域等价类内，可以结合弱健壮测试用例结合。
